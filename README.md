# remotex

Elixir fun application that returns users with more than a random number of points

[![CI](https://github.com/lucazulian/remotex/actions/workflows/elixir-ci.yml/badge.svg)](https://github.com/lucazulian/remotex/actions/workflows/elixir-ci.yml)


## About the Application

Remotex is a Elixir Phoenix Api application, with a single endpoint opened at 4000 port.

The application will return, at max 2 but it can return less, users objects which its points are more than a random number.

The application has a PostgreSQL database with two tabls (**users**, and **schema_migrations**) that is composed by four columns:
- `id` autogenerated integer
- `points` an integer that accepts any number between 0 and 100 (comprised)
- `inserted_at` a timestamp
- `updated_at` a timestamp

Together with the migration scripts, in this phase the seeds script would insert 1,000,000 user entities with 0 points.

When the application starts, the `Engine` genserver with a default `EngineState` state:
- `max_number` a integer random number between 0 and 100 (comprised)
- `queried_at` a timestamp, which indicates the last time someone queried the genserver (nil for first query)

The `Engine` genserver with run a periodic action every minute in which all record in user's table are updated using a random number generator between 0 and 100 (comprised).
Together with the database action, the `max_number` in `Engine` genserver would be updated with a new random value between 0 and 100 (comprised).

For testing purposes, all these operation are delegate to `EngineState` struct and `UsersQueryBulkBehaviour` behaviour. In this way it's possible to unit test the above business logic without the problems presented by testing it with OTP infrastructure.
There are also integration tests that exercise the business logic with OTP infrastructure.

In the *test* configuration  the is a `NoOpUsersQueryBulk` that return fake responses, while the other environments the is the real implementation for the be behaviour.

All timestamp, from database to response one,  are represented in UTC. 


``` bash
curl http://localhost:4000/ | jq
```

The result would be:

``` json
{
  "timestamp": "2021-10-21T19:18:40.835195Z",
  "users": [
    {
      "id": 45,
      "points": 96
    },
    {
      "id": 12,
      "points": 89
    }
  ]
}

```


## Requirements
  
  - postgres **14.0+**
  - Erlang/OTP **24**
  - elixir **1.12.3**
  
  or

  - docker **20+**
  - docker-compose **1.29+**
  - GNU make **4+**
  

## Development links

  * [Conventional Commits][1]
  * [Elixir Style Guide][2]

  [1]: https://www.conventionalcommits.org/en/v1.0.0/
  [2]: https://github.com/christopheradams/elixir_style_guide


## Getting started

### Local environment

In your local environment it needs to install all **Requirements** and requires you to have setup PostgreSQL beforehand.

#### Gets all dependencies

```bash
mix deps.get
```

#### Setup PostgreSQL instance, start migration and seeds scripts

```bash
mix setup
```

#### Start application

```bash
mix phx.server
```


### Docker Compose

Docker Compose is used to simplify development and components installation (like PostgreSQL) and configurations.
Makefile is used as a wrapper around docker-compose commands.
Some commands are aliases around mix aliases, just to avoid boring and repetitive commands. 

#### Make commands

```bash
build                          Build all services containers
delete                         Delete all containers, images and volumes
halt                           Shoutdown all services containers
init                           Setup application components
setup                          Setup application database
shell                          Enter into remotex service
start                          Start application
up                             Start all services
```

#### Setup the project

```bash
make init
```

#### Start the project

```bash
make start
```

#### Destroy environment

```bash
make delete
```


## API Documentation

API design and documentation are available at `http://localhost:4000/doc/swagger`, this contains a live suite to try real endpoints. 
Please consider this endpoint should be moved to a private or protected endpoint in production.


## Monitoring

Basic monitoring is available through *Phoenix LiveDashboard* available at `http://localhost:4000/private/dashboard/home`.
Please consider this endpoint should be moved to a private or protected endpoint in production.


## Improvements / Missing parts

- add structured logs
- add telemetry stuff
- add opentelemetry stuff
- add monitoring and business metrics
- introduce chaos monkey / mutation testing
- increase code coverage
- move `/private` and `/doc` to private or protected endpoints
- add release optimizations and configurations
