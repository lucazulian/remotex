# remotex

Elixir fun application that returns users with more than a random number of points

[![CI](https://github.com/lucazulian/remotex/actions/workflows/elixir-ci.yml/badge.svg)](https://github.com/lucazulian/remotex/actions/workflows/elixir-ci.yml)


## About the Application

Remotex is a Elixir Phoenix Api application, with a single endpoint opened at `4000` port.

The application will return, at max 2 but it can return less, users objects which its points are more than a random number.

The application has a PostgreSQL database with two tables (**users**, and **schema_migrations**) composed by four columns:
- `id` autogenerated integer
- `points` an integer that accepts any number between 0 and 100 (comprised)
- `inserted_at` a timestamp
- `updated_at` a timestamp

Together with the migration scripts, in this phase the seeds script would insert 1,000,000 user entities with default 0 points.

When the application starts, the `Engine` genserver starts with a default `EngineState` state:
- `max_number` a integer random number between 0 and 100 (comprised)
- `queried_at` a timestamp, which indicates the last time someone queried the genserver (`nil` for first query)

The `Engine` genserver run a periodic action every minute in which all records in user's table are updated using a random number generator between 0 and 100 (comprised).
Together with the database action, the `max_number` in `Engine` genserver would be updated with a new random value between 0 and 100 (comprised).
The `Engine` genserver has a `query_users` api which retrieve a max of 2 users with more points than `max_number` previously mentioned. 

For testing purposes, all these operations are delegate to `EngineState` struct and `EngineOperations` module.
For the same reason, in order to test periodic action without wait some intervals, `Engine` genserver has two modes:
- `periodic` which is the default and allow periodic actions
- `manual` which is used by test to trigger manually the `handle_info`

`EngineState` is responsible to init and update genserver state, while to `EngineOperations` are delegate all engine's operation available in the application.

In this way it's possible to unit test the above business logic without the problems presented by testing it with OTP infrastructure.
There are also integration tests that exercise the business logic with OTP infrastructure.

In order to simplify the implementation, the asynchronous parts are delegated to task without monitoring nor crash control.
There is no control over the overlap of asynchronous tasks that could cause problems for the database.
These points would be something that can be improved.

Calling the root `/` endpoint:

``` bash
curl http://localhost:4000/ | jq
```

The result would be something like:

``` json
{
  "timestamp": "2021-10-21T19:18:40.835195Z",
  "users": [
    {
      "id": 45,
      "points": 96
    },
    {
      "id": 12,
      "points": 89
    }
  ]
}

```

where `timestamp` represent the timestamp of the previous query (in the first would be `nil`) and `users` represents a list of at most 2 elements with `id` and `points` data following the previous roles.

All timestamps, from database to response one,  are represented in UTC. 


## Requirements
  
  - postgres **14.0+**
  - Erlang/OTP **24**
  - elixir **1.12.3**
  
  or

  - docker **20+**
  - docker-compose **1.29+**
  - GNU make **4+**
  

## Development links

  * [Conventional Commits][1]
  * [Elixir Style Guide][2]

  [1]: https://www.conventionalcommits.org/en/v1.0.0/
  [2]: https://github.com/christopheradams/elixir_style_guide


## Getting started

### Local environment

In your local environment it needs to install all **Requirements** and requires you to have setup PostgreSQL beforehand.

#### Gets all dependencies

```bash
mix deps.get
```

#### Setup PostgreSQL instance, start migration and seeds scripts

```bash
mix setup
```

#### Start application

```bash
mix phx.server
```


### Docker Compose

Docker Compose is used to simplify development and components installation (like PostgreSQL) and configurations.
Makefile is used as a wrapper around docker-compose commands.
Some commands are aliases around mix aliases, just to avoid boring and repetitive commands. 

#### Make commands

```bash
build                          Build all services containers
delete                         Delete all containers, images and volumes
halt                           Shoutdown all services containers
init                           Setup application components
setup                          Setup application database
shell                          Enter into remotex service
start                          Start application
up                             Start all services
```

#### Setup the project

```bash
make init
```

#### Start the project

```bash
make start
```

#### Destroy environment

```bash
make delete
```


## API Documentation

API design and documentation are available at `http://localhost:4000/doc/swagger`, this contains a live suite to try real endpoints. 
Please consider this endpoint should be moved to a private or protected endpoint in production.


## Monitoring

Basic monitoring is available through *Phoenix LiveDashboard* available at `http://localhost:4000/private/dashboard/home`.
Please consider this endpoint should be moved to a private or protected endpoint in production.


## Improvements / Missing parts

- add structured logs
- add telemetry stuff
- add opentelemetry stuff
- add monitoring and business metrics
- introduce chaos monkey / mutation testing
- increase code coverage
- move `/private` and `/doc` to private or protected endpoints
- add release optimizations and configurations
